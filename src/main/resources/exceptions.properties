interpreter.identifier=could not find declaration: %s
interpreter.call.lambda=can not call non lambda terms with parameters: %s

java.copy=can not copy java object
java.print=can not print java object
java.substitute=can not substitute java object

module.find=could not find module '%s'

operation.additive.operands=invalid operands in additive term: %s
operation.concat.operands=invalid operands in concatenation
operation.conditional.operands=condition must be a boolean value: %s
operation.index.identifier=can only use an identifier as map access: %s
operation.index.numbers=numbers expected as indices
operation.index.operands=invalid operands in element access: %s
operation.index.double=can not use double constant as index: %s
operation.multiplicative.operands=invalid operands in multiplicative term
operation.negation.operands=invalid operand in negation
operation.relational.operands=invalid operands in relational term
operation.relational.operator=unimplemented operator in relational term
operation.shift.operands=invalid operands in shift term

parser.call=')' expected at the end of function call
parser.char.begin=''' expected
parser.conditional.then=':' expected
parser.lambda.let.begin='(' expected before let-declaration
parser.lambda.let.end=')' expected after let-declaration
parser.lambda=invalid lambda
parser.list.begin='[' expected
parser.list.end=']' expected
parser.map.begin='{' expected
parser.map.pair=':' expected
parser.map.end='}' expected
parser.module.name=module name expected after '@'
parser.module.deps=list expected as module dependencies
parser.module.dep=identifier expected as dependency name
parser.operator=no function for given operator '%s'
parser.parenthesis=')' expected to complete term in parenthesis
parser.string.begin='"' expected
parser.term=invalid term

pattern.default.missing=lambda specialization of '%s' without default declaration